REGEX стриги запросов:
.* - вернуть всё
[A].* - вернуть всё, что начинается с символа А
^\d.* - вернуть всё, что начинается с цифры
[^A]* - вернуть всё, что не начинается с символа А
.*[U] - вернуть всё, что заканчивается символом U
.*[J]$ - аналогично предыдущему варианту
.*[b].* - вернуть всё, где есть символ b
.*[bac].* - вернуть всё, где есть символы b, a, c
.*\d.* - вернуть всё, где есть цифры

Тестирование методик сравнения
На моих настройках(ParsersTest.java):
SimpleMatcher(100 повторений - в м/с): 21-24
PatternMatcher(100 повторений - в м/с): 7-8
ApacheMatcher(100 повторений - в м/с): 7-8
Был выбран методк основанный на библиотеке Apache.

P.S.:
По причине CVE-2016-6816 Tomcat отказывается работать с символами "^", "$" и "\" в строке запроса. У меня было три варианта:
1)Перевести стринги запросов в RequestBody и отправлять данные в json методом POST.
2)Запустить приложение на embedded Jetty
3)В сервис-слое заменять символ "^" на другой символ, например "!" и аналогично для других.

Был протестирован и выбран второй вариант и Jetty успешно работает с символами: ^, \, $.

P.S.2:
Были опробованы две методики итерации - с помощью парралельного стрима и самописный на основе ThreadExecutorPool и Future:

1)List<Contact> contacts = data.parallelStream().filter(c -> regexValidator.isValid(c.getName())).collect(Collectors.toList());

2)Текущая методика на основе класса DataCollector.
Запрос: localhost:8080/hello2/contacts?nameFilter=d.*
Тайминги (в м/с):
Parralel Stream: 426,567,552,1023,364
DataCollector: 253,390,298,196,302

По общей оценке скорости выполнения текущий вариант оказался более быстрым, хотя и более прожорливым к памяти за счёт большего количества объектов.